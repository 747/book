// Generated by dts-bundle v0.7.3

declare module '@wenyanlang/core' {
    import { CompileOptions, ASCNode, Token, ExecuteOptions } from "@wenyanlang/core/types";
    import { hanzi2num, hanzi2numstr, num2hanzi, bool2hanzi } from "@wenyanlang/core/converts/hanzi2num";
    import { hanzi2pinyin } from "@wenyanlang/core/converts/hanzi2pinyin";
    import { version } from "@wenyanlang/core/version";
    import { NUMBER_KEYWORDS, KEYWORDS } from "@wenyanlang/core/keywords";
    import { STDLIB } from "@wenyanlang/core/stdlib";
    import { evalCompiled } from "@wenyanlang/core/execute";
    function wy2tokens(txt: string, assert?: (msg: string, pos: number, b: any) => void): Token[];
    function tokens2asc(tokens: Token[], assert?: (msg: string, pos: number, b: any) => void): ASCNode[];
    function compile(txt: string, options?: Partial<CompileOptions>): string;
    function execute(source: string, options?: Partial<ExecuteOptions & CompileOptions>): void;
    export { compile, evalCompiled, execute, version, wy2tokens, tokens2asc, hanzi2num, hanzi2numstr, num2hanzi, bool2hanzi, hanzi2pinyin, KEYWORDS, NUMBER_KEYWORDS, STDLIB };
}

declare module '@wenyanlang/core/types' {
    export type TargetLanguages = "js" | "py" | "rb";
    export type RomanizeSystem = "none" | "pinyin" | "unicode" | "baxter";
    export type LogCallback = (...args: any[]) => void;
    export type CacheObject = Record<string, string>;
    export type StandardLibraryObject = Record<string, string> & Record<TargetLanguages, Record<string, string>>;
    export interface CompileOnlyOptions {
        lang: TargetLanguages;
        romanizeIdentifiers: RomanizeSystem;
        resetVarCnt: boolean;
        logCallback: LogCallback;
        errorCallback: LogCallback;
        lib: StandardLibraryObject;
        strict: Boolean;
    }
    export interface ImportOptions {
        entryFilepath?: string;
        importPaths: string | string[];
        importCache: CacheObject;
        importContext: Record<string, string | {
            entry: string;
            src?: string;
        }>;
        allowHttp: boolean;
        trustedHosts: string[];
        requestTimeout: number;
    }
    export type CompileOptions = CompileOnlyOptions & ImportOptions;
    export interface MarcoOptions {
        lib: CompileOnlyOptions["lib"];
        lang: TargetLanguages;
        importOptions: ImportOptions;
    }
    export interface TranspilerOptions {
        imports: string[];
    }
    export interface ExecuteOptions {
        lang: TargetLanguages;
        outputHanzi: boolean;
        scoped: boolean;
        output: LogCallback;
    }
    export type MacroDefinition = [string, string];
    export interface ImportedModule {
        moduleName: string;
        src: string;
        entry?: string;
    }
    export type TokenType = "ans" | "assgn" | "bool" | "call" | "cmp" | "comment" | "ctnr" | "ctrl" | "data" | "decl" | "discard" | "expr" | "iden" | "import" | "lit" | "lop" | "macro" | "mod" | "name" | "not" | "num" | "op" | "opord" | "print" | "rassgn" | "take" | "try" | "type" | "throw";
    export type Token = [TokenType, string | undefined, number] | ["ans"];
    export interface ASCNodeCommon {
        pos: number;
    }
    export interface ASCNodeOperator {
        op: "op+" | "op-" | "op/" | "op%";
        lhs?: Token;
        rhs?: Token;
    }
    export interface ASCNodeReturn {
        op: "return";
        value?: Token;
    }
    export interface ASCNodeIf {
        op: "if";
        test: Token[];
        elseif?: boolean;
        not?: boolean;
    }
    export interface ASCNodeFunction {
        op: "fun";
        arity: number;
        args: {
            name: string;
            type: string;
        }[];
        elseif?: boolean;
        not?: boolean;
    }
    export interface ASCNodeWithValue {
        op: "not" | "whilen" | "comment";
        value: Token;
    }
    export interface ASCNodeName {
        op: "name";
        names: string[];
    }
    export interface ASCNodeReassign {
        op: "reassign";
        lhs: Token;
        rhs?: Token;
        lhssubs?: Token;
        rhssubs?: Token;
        del?: boolean;
    }
    export interface ASCNodeCat {
        op: "cat";
        containers: Token[];
    }
    export interface ASCNodeFor {
        op: "for";
        container: Token;
        iterator: string;
    }
    export interface ASCNodeCall {
        op: "call";
        fun: Token;
        args?: Token[];
        pop?: boolean;
    }
    export interface ASCNodeLength {
        op: "length";
        container: Token;
    }
    export interface ASCNodeTake {
        op: "take";
        count: number;
    }
    export interface ASCNodeTemp {
        op: "temp";
        iden: Token;
    }
    export interface ASCNodeImport {
        op: "import";
        file: string;
        iden: string[];
    }
    export interface ASCNodePush {
        op: "push";
        container: Token;
        values: Token[];
    }
    export interface ASCNodeWithError {
        op: "catcherr" | "throw";
        error?: Token;
        message?: Token;
        name?: string;
    }
    export interface ASCNodeSubscript {
        op: "subscript";
        container: Token;
        value: Token;
    }
    export interface ASCNodeVariable {
        op: "var";
        count: number;
        type: string;
        values: (Token | [])[];
        public: boolean;
        names?: string[];
    }
    export interface ASCNodePropertry {
        op: "prop";
        type: string;
        name: string;
        value: Token;
    }
    export interface ASCNodeGlobal {
        op: "global";
    }
    export interface ASCNodeEOF {
        op: "EOF";
    }
    export interface ASCNodeSimple {
        op: "break" | "end" | "print" | "else" | "continue" | "objbody" | "funbody" | "whiletrue" | "try" | "tryend" | "catch" | "discard" | "funend" | "objend";
    }
    export type ASCNode = ASCNodeCommon & (ASCNodeOperator | ASCNodeSimple | ASCNodeReturn | ASCNodeIf | ASCNodeFunction | ASCNodeWithValue | ASCNodeName | ASCNodeReassign | ASCNodeImport | ASCNodeTake | ASCNodeWithError | ASCNodeTemp | ASCNodeCat | ASCNodeFor | ASCNodeLength | ASCNodePush | ASCNodeCall | ASCNodeSubscript | ASCNodeVariable | ASCNodePropertry | ASCNodeGlobal | ASCNodeEOF);
    export function isASCNodeOperator(node: ASCNode): node is ASCNodeCommon & ASCNodeOperator;
    export interface IdenType {
        type: "any" | "nil" | "fun" | "obj" | "arr" | "str" | "bol" | "num" | string;
        name?: string;
        isarg?: boolean;
        in?: IdenType;
        out?: IdenType;
        element?: IdenType;
        fields?: {};
    }
    export type TypeScope = Record<string, IdenType>;
    export type TypeSignature = [[number, number, number], TypeScope][];
}

declare module '@wenyanlang/core/converts/hanzi2num' {
    export enum NumberTokenType {
        SIGN = 0,
        DIGIT = 1,
        DECIMAL = 2,
        INT_MULT = 3,
        FRAC_MULT = 4,
        DELIM = 5,
        ZERO = 6,
        BEGIN = 7,
        END = 8
    }
    export type Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
    export type NumberToken = {
        type: NumberTokenType.ZERO | NumberTokenType.DIGIT;
        digit: Digit;
    } | {
        type: NumberTokenType.SIGN;
        sign: number;
    } | {
        type: NumberTokenType.DECIMAL | NumberTokenType.INT_MULT | NumberTokenType.FRAC_MULT;
        exp: number;
    } | {
        type: NumberTokenType.DELIM | NumberTokenType.BEGIN | NumberTokenType.END;
    };
    export interface ParseResult {
        sign: number;
        exp: number;
        digits: Digit[];
    }
    export function hanzi2numstr(s: string): string | null;
    export function hanzi2num(s: string): number;
    export function num2hanzi(n: number, format?: string, precision?: any): string;
    export function bool2hanzi(b: boolean): string;
}

declare module '@wenyanlang/core/converts/hanzi2pinyin' {
    import { RomanizeSystem } from "@wenyanlang/core/types";
    export function hanzi2unicodeEntry(s: string): string;
    export function hanzi2pinyin(a: string, system?: RomanizeSystem): string;
}

declare module '@wenyanlang/core/version' {
    const version: string;
    export { version };
}

declare module '@wenyanlang/core/keywords' {
    import { TokenType } from "@wenyanlang/core/types";
    export const NUMBER_KEYWORDS: string[];
    export const KEYWORDS_DEFINE: Record<string, [TokenType, string | undefined]>;
    export const KEYWORDS: {
        [x: string]: [TokenType, string];
        [x: number]: [TokenType, string];
    };
}

declare module '@wenyanlang/core/stdlib' {
    import { StandardLibraryObject } from "@wenyanlang/core/types";
    export const STDLIB: StandardLibraryObject;
}

declare module '@wenyanlang/core/execute' {
    import { TargetLanguages, LogCallback, ExecuteOptions } from "@wenyanlang/core/types";
    export function isLangSupportedForEval(lang: TargetLanguages): boolean;
    export function outputHanziWrapper(log: LogCallback, outputHanzi: boolean): (...args: any[]) => void;
    export function evalCompiled(compiledCode: string, options?: Partial<ExecuteOptions>): void;
}

